# Quicksort in Python: A Detailed Guide

## Introduction

**Quicksort is a highly efficient divide-and-conquer sorting algorithm. Its average time complexity is O(n log n), making it a popular choice for sorting large datasets. Here's a detailed implementation in Python.**

## Core Implementation

```python
def partition(arr, low, high):
    """Partitions the array and places the pivot in its correct sorted position.

    Args:
        arr: The array to be partitioned.
        low: The starting index of the subarray.
        high: The ending index of the subarray.

    Returns:
        The index of the correctly placed pivot element.
    """

    pivot = arr[high]  # Select the last element as the pivot
    i = low - 1        # Index for smaller elements

    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]  # Swap if the element is smaller

    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # Put the pivot in its sorted place
    return i + 1  # Return the partition index

def quick_sort(arr, low, high):
    """Recursively sorts the array using Quicksort.

    Args:
        arr: The array to be sorted.
        low: The starting index of the subarray.
        high: The ending index of the subarray.
    """

    if low < high:
        partition_index = partition(arr, low, high)
        quick_sort(arr, low, partition_index - 1)  # Sort elements before partition
        quick_sort(arr, partition_index + 1, high)  # Sort elements after partition

# Example usage
numbers = [7, 2, 10, 1, 9, 5]
quick_sort(numbers, 0, len(numbers) - 1)
print(numbers)  # Output: [1, 2, 5, 7, 9, 10]
```

## Explanation

1. **`partition(arr, low, high)`**
   * **Purpose:** Rearranges the array (from index `low` to `high`) around a chosen pivot element. It ensures:
      - Elements smaller than the pivot are placed before it.
      - Elements greater than the pivot are placed after it.
      - The pivot is placed in its final sorted position.
   * **Steps:**
     * The last element is chosen as the pivot.
     * An index `i` tracks the boundary between smaller and larger elements.
     * The function iterates through the subarray. If an element is smaller than or equal to the pivot, it's swapped into the section of smaller elements.
     * Finally, the pivot is placed at its correct sorted position (`i + 1`).
     * It returns the index of the correctly placed pivot.

2. **`quick_sort(arr, low, high)`**
   * **Purpose:** The main recursive Quicksort function.
   * **Base Case:** If the subarray has one or fewer elements (`low >= high`), it's considered sorted.
   * **Partitioning:** Calls the `partition` function to get the index of the correctly placed pivot.
   * **Recursion:**  Recursively applies `quick_sort` to the two subarrays â€“ one containing elements before the pivot and one containing elements after the pivot.

**Key Points and Considerations**

* **Pivot Selection:** The choice of pivot can impact Quicksort's performance. Picking the first, last, a random element, or using median-of-three strategies are common choices.
* **Efficiency:**  Average time complexity O(n log n); worst-case can be O(n^2) with poor pivot choices.
* **In-place Sorting:**  Quicksort works in-place, modifying the original array.

### Note:

#### _This page is Generated by [Gemini Advanced](https://g.co/gemini/share/fad7821db065)_
